# Ветвления и крайние случаи в unit‑тестах: как покрывать границы и “плохие” входы и делать тесты самодокументируемыми

Один тест на “типичное значение” почти всегда даёт ложное чувство надёжности. Большая доля дефектов живёт не в центре диапазона, а на краях: `0` вместо `1`, пустая строка вместо строки, `None` вместо объекта, “чуть больше максимума”, “чуть меньше минимума”. И отдельно — ветвления: код может быть выполнен “по строкам”, но не “по исходам условий”. Из‑за этого тесты проходят, а дефект скрывается до реального инцидента.

В `unittest` тест по смыслу должен быть самодостаточным и запускаться изолированно или в произвольной комбинации с другими. Это требование напрямую связано с тем, как Вы проектируете проверки ветвей и крайних случаев: каждый тест обязан сам создавать входные условия и явно фиксировать ожидаемый результат. ([Python documentation][1])

## Покрытие ветвей: что именно нужно закрыть, а не “пройтись по строкам”

Покрытие “ветвей” (branch/decision coverage) — это не про количество выполненных строк. Это про то, что **каждый исход каждого условия** был выполнен тестами: условие стало `True` и стало `False`. Для `if` это означает, что выполнялись и “then”, и “else” (даже если `else` не написан). Именно так обычно формулируют отличие от более слабых метрик: ветвевое покрытие требует выполнить все выходы из условного оператора. ([rapitasystems.com][2])

Показательный пример — “частичная ветвь”. Код выполнен полностью по строкам, но одна из возможных “прыжков” управления ни разу не случилась:

```python
def choose_discount(x: int) -> int:
    if x:
        y = 10
    return y
```

Если тесты проверили только `x=1`, строки 1–4 “покрыты”, но исход `if x` как `False` не выполнен. Инструменты ветвевого покрытия показывают это как непокрытую ветвь/переход. ([coverage.readthedocs.io][3])

Практический вывод простой: если в коде есть `if/elif/else`, ранний `return`, `raise`, тернарный оператор, `and/or` в условии — это точки ветвления. Ваша задача не “вызвать функцию”, а **заставить её пройти по каждому смысловому пути хотя бы один раз**.

## Как не утонуть в бесконечном числе входов: эквивалентные классы и границы

Проверять “все значения” невозможно. Поэтому в тест‑дизайне есть два базовых приёма, которые очень хорошо переводятся в unit‑тесты.

**Эквивалентное разбиение (Equivalence Partitioning)**: входной домен делится на классы, внутри которых поведение одинаково, и тестируется представитель каждого класса. В терминах ISTQB это black‑box техника, где условие покрывается одним представителем каждой эквивалентной области. ([ISTQB Glossary][4])

**Анализ граничных значений (Boundary Value Analysis)**: ошибки часто возникают на границах эквивалентных классов, поэтому дополнительно проверяются минимумы/максимумы и значения “рядом” с ними. В материалах ISTQB граничные значения описываются как минимум и максимум упорядоченного класса, то есть его границы. ([istqb.org][5])

Для числового диапазона `[min, max]` типовой набор вокруг границы выглядит так:

* “на границе”: `min`, `max`
* “внутри рядом”: `min+1`, `max-1`
* “снаружи рядом”: `min-1`, `max+1`

Важно не механически выписывать “±1”, а осознать шаг домена. Для денег шаг — 1 цент, для длины строки — 1 символ, для даты — 1 день, для веса в граммах — 1 грамм.

## Пустые значения и `None`: почему это отдельный класс дефектов

В Python много значений “ложные” (`False`, `0`, `""`, `[]`, `{}`, `None`). Частая ошибка — не различать “пусто” и “отсутствует”. Например, `""` как пользователь ввёл пустую строку и `None` как поле вообще не передали — это разные состояния и часто разные ошибки.

Если логика использует проверку вида `if value:`, Вы обязаны тестом зафиксировать, что происходит при `value=""`, `value=0`, `value=None`. Иначе дефект будет выглядеть как “в редких случаях пропали данные”, а на самом деле это один непротестированный край.

## Неверные типы: в динамическом языке контракт нужно зафиксировать тестами

В Python программа может “принять” неправильный тип и упасть где‑то позже с неожиданной ошибкой. Для unit‑теста полезно сформулировать контракт явно: функция принимает только `int`, или принимает `int` и строку‑цифры, или принимает любой объект с `__int__`. Это решение должно быть видно из тестов.

Если контракт “тип неверный → `TypeError`”, проверка должна быть через `assertRaises(TypeError)`, без `try/except` в тесте. Так тест становится не только проверкой, но и спецификацией поведения.

## Практический алгоритм: как превратить ветви и крайние случаи в набор тестов

1. Выпишите “решения” в коде. Каждое `if/elif/else`, каждое место, где может быть `raise`, каждое раннее завершение — отдельная ветвь.

2. Для каждого входа определите эквивалентные классы. Отдельно выделите “валидные” и “невалидные” классы: пусто, отсутствует, неверный формат, неверный тип. ([ISTQB Glossary][4])

3. Для классов с диапазонами добавьте граничные значения: минимум/максимум и соседние значения “внутри/снаружи”. ([istqb.org][5])

4. Скомпонуйте минимальный набор кейсов, который закрывает все ветви. Это место, где легко получить комбинаторный взрыв. Комбинировать допустимо, но только пока тест остаётся диагностируемым: падение должно указывать на одну причину, а не на “комбо из трёх параметров”.

5. Сделайте тесты самодокументируемыми: название теста, структура AAA, минимальная логика внутри теста, выразительные assert‑методы, маркировка параметров через `subTest` при табличных проверках. `unittest` прямо поддерживает `subTest()` как способ различать итерации внутри одного теста, показывая параметры при падении. ([Python documentation][1])

## Пример: функция с ветвлениями и границами и тесты, которые читаются как спецификация

Ниже — пример “прикладной” функции, где есть ветви по диапазонам и по параметрам, плюс проверка типов. Домен специально сделан дискретным (граммы, целые цены), чтобы убрать ошибки округления.

### Код (SUT)

```python
# src/shipping/pricing.py

ZONES = {"local", "domestic", "intl"}

def shipping_price_cents(weight_g: int, zone: str, express: bool = False) -> int:
    """
    Рассчитывает цену доставки.

    Контракт:
    - weight_g: int, 1..30000 включительно
    - zone: "local" | "domestic" | "intl"
    - express: bool, если True — +30% к промежуточной сумме (округление вверх)
    """
    if isinstance(weight_g, bool) or not isinstance(weight_g, int):
        raise TypeError("weight_g must be int")
    if not isinstance(zone, str):
        raise TypeError("zone must be str")
    if not isinstance(express, bool):
        raise TypeError("express must be bool")

    if weight_g < 1 or weight_g > 30_000:
        raise ValueError("weight_g out of range")
    if zone not in ZONES:
        raise ValueError("unknown zone")

    base = {"local": 500, "domestic": 900, "intl": 2500}[zone]

    if weight_g <= 500:
        surcharge = 0
    elif weight_g <= 2_000:
        surcharge = 200
    elif weight_g <= 10_000:
        surcharge = 700
    else:
        surcharge = 1500

    subtotal = base + surcharge

    if express:
        subtotal += (subtotal * 30 + 99) // 100  # +30%, округление вверх

    return subtotal
```

В этом коде легко увидеть ветви:

* 3 ветви по типам (TypeError),
* 2 ветви по диапазону веса (ValueError/OK),
* 2 ветви по зоне (ValueError/OK),
* 4 ветви по интервалам веса,
* 2 ветви по `express`.

### Визуальная “карта” интервалов веса

| Интервал веса (г) | Надбавка |
| ----------------: | -------: |
|             1–500 |        0 |
|          501–2000 |      200 |
|        2001–10000 |      700 |
|       10001–30000 |     1500 |

Это уже даёт эквивалентные классы. А BVA подсказывает конкретные “краевые” значения: 1, 500, 501, 2000, 2001, 10000, 10001, 30000 и два “снаружи” — 0 и 30001. ([istqb.org][5])

### Тесты: ветви + границы + самодокументируемость

Обратите внимание на три вещи: явные ожидания, минимальная логика, и `subTest` с параметрами — при падении отчёт покажет, на каком кейсе тест сломался. ([Python documentation][1])

```python
# tests/test_pricing.py
import unittest

from shipping.pricing import shipping_price_cents

class TestShippingPrice(unittest.TestCase):
    def test_raises_type_error_on_wrong_types(self):
        # Arrange / Act / Assert
        with self.assertRaises(TypeError):
            shipping_price_cents("100", "local")   # weight_g не int

        with self.assertRaises(TypeError):
            shipping_price_cents(100, 123)         # zone не str

        with self.assertRaises(TypeError):
            shipping_price_cents(100, "local", "yes")  # express не bool

        # Важно: bool — подкласс int, часто это нежелательно
        with self.assertRaises(TypeError):
            shipping_price_cents(True, "local")

    def test_raises_value_error_on_out_of_range_weight(self):
        # Arrange / Act / Assert
        for w in (0, -1, 30_001):
            with self.subTest(weight_g=w):
                with self.assertRaises(ValueError):
                    shipping_price_cents(w, "local")

    def test_raises_value_error_on_unknown_zone(self):
        # Arrange / Act / Assert
        with self.assertRaises(ValueError):
            shipping_price_cents(100, "mars")

    def test_price_by_weight_boundaries_local_no_express(self):
        # Arrange: таблица граничных значений и ожидаемых цен
        cases = [
            (1,     500),  # base 500 + 0
            (500,   500),
            (501,   700),  # base 500 + 200
            (2000,  700),
            (2001,  1200), # base 500 + 700
            (10000, 1200),
            (10001, 2000), # base 500 + 1500
            (30000, 2000),
        ]

        for weight_g, expected in cases:
            with self.subTest(weight_g=weight_g):
                # Act
                actual = shipping_price_cents(weight_g, "local", express=False)
                # Assert
                self.assertEqual(actual, expected)

    def test_express_adds_30_percent_rounded_up(self):
        # Arrange
        weight_g = 501          # local: 500 + 200 = 700
        expected = 700 + (700 * 30 + 99) // 100  # 700 + 210 = 910

        # Act
        actual = shipping_price_cents(weight_g, "local", express=True)

        # Assert
        self.assertEqual(actual, expected)

if __name__ == "__main__":
    unittest.main(verbosity=2)
```

Почему эти тесты “самодокументируемые”:

* имена тестов сразу говорят, какой контракт проверяется (`raises_type_error…`, `price_by_weight_boundaries…`);
* в каждом тесте видно AAA‑структуру (подготовка → действие → проверка);
* ожидаемые значения не вычисляются “тем же алгоритмом”, что и прод‑код, кроме маленького фрагмента в express‑тесте (там это допустимо, потому что цель теста — именно формула +30% и округление);
* `subTest(weight_g=...)` делает табличные проверки диагностируемыми: если упадёт кейс `weight_g=2001`, это будет видно в отчёте. ([Python documentation][1])

## Как не превратить покрытие ветвей в “100 тестов на 1 функцию”

Покрытие ветвей — это не про “все комбинации”. Это про минимальный набор, который заставляет код пройти по каждому смысловому пути. Чтобы не раздувать набор:

* Для проверки интервалов веса достаточно держать `zone` постоянной и менять только `weight_g`. Так Вы закрываете 4 ветви интервалов.
* Для проверки зон достаточно взять один “серединный” вес (например, 1000) и прогнать 3 зоны. Это закрывает ветвь выбора базы.
* Для `express` достаточно одной-двух репрезентативных точек, где округление может дать “вверх” (например, сумма, не кратная 10).

Эта композиция даёт ветвевое покрытие без комбинаторного взрыва.

## Дополнительные материалы

`unittest`: самодостаточность `TestCase`, порядок запуска тестов, фикстуры и механизм `subTest`. ([Python documentation][1])
ISTQB Glossary: определение эквивалентного разбиения. ([ISTQB Glossary][4])
ISTQB White Paper: принципы boundary value analysis и роль минимумов/максимумов как границ. ([istqb.org][5])
Branch/Decision coverage: требование выполнять оба исхода решения (true/false) как смысл ветвевого покрытия. ([rapitasystems.com][2])
coverage.py: что такое “partial branch” и как измерять ветвевое покрытие (как инструмент, опционально). ([coverage.readthedocs.io][3])

## Практическое задание

## Цель

Написать функцию с ветвлениями и строгим контрактом на входы, покрыть её unit‑тестами так, чтобы были закрыты все смысловые ветви, границы диапазона, пустые значения и неверные типы. Тесты должны читаться как спецификация: по именам и структуре должно быть понятно, что проверяется.

## Задание (шаги)

1. Создайте минимальный репозиторий (src layout), чтобы импорты были предсказуемыми:

```text
qa-branches-homework/
├─ pyproject.toml
├─ src/
│  └─ netutils/
│     ├─ __init__.py
│     └─ ports.py
└─ tests/
   ├─ __init__.py
   └─ test_ports.py
```

2. Установите проект в editable режиме в виртуальном окружении:

```bash
python -m pip install -e .
```

3. В `src/netutils/ports.py` создайте заглушку функции:

```python
def parse_port(value):
    """Преобразует value в номер порта (int) и валидирует диапазон."""
    raise NotImplementedError
```

4. В `tests/test_ports.py` напишите тесты на функцию `parse_port(value)` по спецификации ниже. Начните с “красного” прогона.

5. Реализуйте `parse_port`, чтобы все тесты стали зелёными.

6. Запуск должен работать discovery‑командой из корня проекта:

```bash
python -m unittest discover -s tests -t . -v
```

## Подсказки по ключевым частям

Спецификация `parse_port(value)`:

* Принимает `int` или `str`.
* Если `value` — `int`, то он должен быть в диапазоне **1..65535** включительно, иначе `ValueError`.
* Если `value` — `str`, то:

  * строка сначала `strip()`;
  * после `strip()` она должна состоять только из цифр (`isdigit()`), иначе `ValueError`;
  * затем конвертируется в `int` и проверяется диапазон **1..65535**, иначе `ValueError`.
* Любой другой тип → `TypeError`.
* `bool` должен считаться неверным типом (в Python `bool` — подкласс `int`, поэтому это отдельная ветвь).

Как превратить это в тесты без взрыва количества:

* Для `int` и `str` выделите эквивалентные классы “валидно/невалидно” и добавьте граничные значения 0/1/65535/65536. ([ISTQB Glossary][4])
* Для строк добавьте пустую строку, строку из пробелов, строку с `+`, строку с `-`, строку с буквами.
* Для “неверного типа” достаточно 3–4 представителей: `None`, `[]`, `{}`, `3.14`.

Для табличных кейсов используйте `subTest(value=...)`: так один тест‑метод будет содержать несколько подкейсов, а отчёт покажет конкретное значение при падении. ([Python documentation][1])

## Что проверить перед отправкой (чек-лист)

* Команда `python -m unittest discover -s tests -t . -v` проходит с `OK` и действительно запускает Ваши тесты (не `Ran 0 tests`). ([Python documentation][1])
* Есть тесты на границы: `0`, `1`, `2`, `65534`, `65535`, `65536` (как минимум часть из них). ([istqb.org][5])
* Есть тесты на пустые значения: `""`, `"   "` (после strip становится пусто).
* Есть тесты на неверные типы: `None`, `[]`, `{}`, `3.14`, а также отдельно `True/False`.
* Нет `try/except` в тестах для проверки ошибок: используется `assertRaises`.
* Тесты самодокументируемые: имена методов отражают контракт, табличные кейсы помечены через `subTest`. ([Python documentation][1])
* В тестах минимум логики: expected‑значения и ожидаемые исключения заданы явно.

## Советы по улучшению работы

* После зелёного прогона измерьте ветвевое покрытие через `coverage.py --branch`, чтобы увидеть “частичные ветви” и недостающие исходы условий. Это не обязательно для сдачи, но хорошо подсвечивает пробелы. ([coverage.readthedocs.io][3])
* Если тесты стали длинными, вынесите только повторяющуюся “шумовую” часть (например, запуск функции) в маленький helper в тестах, но не прячьте в helper сами входы и ожидания — иначе пропадёт самодокументируемость.
* Если при реализации получилось много вложенных `if`, добавьте отдельные проверки входов (type/range) в начале функции. Это упрощает ветвление и делает тесты более линейными.

[1]: https://docs.python.org/3/library/unittest.html "unittest — Unit testing framework — Python 3.14.3 documentation"
[2]: https://www.rapitasystems.com/difference-between-decision-coverage-and-branch-coverage?utm_source=chatgpt.com "What is the difference between decision coverage and ..."
[3]: https://coverage.readthedocs.io/en/latest/branch.html?utm_source=chatgpt.com "Branch coverage measurement"
[4]: https://glossary.istqb.org/en_US/term/equivalence-partitioning?utm_source=chatgpt.com "equivalence partitioning"
[5]: https://istqb.org/wp-content/uploads/2025/10/Boundary-Value-Analysis-white-paper.pdf?utm_source=chatgpt.com "Boundary Value Analysis According to the ..."
