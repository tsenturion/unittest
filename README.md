# Курс по `unittest` (Python)

Этот репозиторий — программа курса по стандартному фреймворку тестирования `unittest` в Python: от базовых принципов до CI и асинхронных тестов.

## Структура курса

### Модуль 1. База: что и зачем тестируем

1. **1.1)** Unit-тест и «юнит»: определяем границы (функция/метод/класс), что считаем единицей проверки.
2. **1.2)** Термины `unittest`: `test case`, `fixture`, `suite`, `runner` — единый словарь фреймворка.
3. **1.3)** Принцип независимости тестов: каждый тест запускается отдельно и в любом порядке.
4. **1.4)** Структура проекта под тесты: раскладка кода/тестов для стабильного `discovery` и предсказуемых импортов.
5. **1.5)** Практика: «скелет» репозитория + минимальный тест по циклу «красный -> зелёный».

### Модуль 2. `TestCase`: читаемые и надёжные проверки

1. **2.1)** Шаблон AAA (`Arrange-Act-Assert`) в `unittest`.
2. **2.2)** Базовые `assert`-методы: `assertEqual`, `assertTrue`, `assertFalse`, `assertIn`, `assertIs` и другие.
3. **2.3)** Проверка исключений через `assertRaises` (без `try/except` в тесте).
4. **2.4)** Проверка коллекций и сложных объектов: когда важен порядок, а когда нет.
5. **2.5)** Практика: ветвления и крайние случаи (границы, пустые значения, неверные типы), самодокументируемые тесты.

### Модуль 3. Запуск тестов: CLI, точки входа, фильтрация

1. **3.1)** Запуск через `python -m unittest`: модули, классы, отдельные методы.
2. **3.2)** `unittest.main()`: как сделать тест-файл исполняемым напрямую.
3. **3.3)** Полезные опции CLI: `-v`, `-f/--failfast`, `-b/--buffer`, `-k`, `--locals`, `--durations`.
4. **3.4)** Test discovery: `python -m unittest discover`, параметры `-s/-p/-t`, требования импортируемости.
5. **3.5)** Практика: настройка `discovery` под проект и запуск подмножеств тестов.

### Модуль 4. Fixtures и жизненный цикл теста: `setUp`/`tearDown` и cleanup

1. **4.1)** `setUp()` / `tearDown()`: гарантии фреймворка, подготовка и очистка без утечек.
2. **4.2)** `setUpClass()` / `tearDownClass()`: когда оправдано, и типовые ловушки.
3. **4.3)** `setUpModule()` / `tearDownModule()`: модульные фикстуры для общего окружения.
4. **4.4)** `addCleanup()` / `enterContext()`: безопасное освобождение ресурсов даже при падениях `setUp()`.
5. **4.5)** Практика: ресурсы (временные файлы/подключения) и доказательство корректной очистки при `success/fail/error`.

### Модуль 5. Организация набора тестов: suites, loaders, runners

1. **5.1)** Пакетирование тестов: когда делать `tests/` пакетом и как не сломать импорты.
2. **5.2)** `TestSuite`: ручная группировка тестов и реальные сценарии применения.
3. **5.3)** `TestLoader` и `discover()`: как строится набор тестов и как на это влиять.
4. **5.4)** `TextTestRunner` и результаты: чтение отчётов и повышение сигнал/шум.
5. **5.5)** `load_tests protocol`: крючок тонкой настройки `discovery` и сборки набора.

### Модуль 6. Управление прогоном: skip, `expectedFailure`, `subTest`

1. **6.1)** Пропуск тестов: `skip`, `skipIf`, `skipUnless`, `SkipTest`.
2. **6.2)** Ожидаемые падения: `expectedFailure` для известных дефектов.
3. **6.3)** `subTest()`: параметризация без сторонних библиотек.
4. **6.4)** Стратегия: много маленьких тестов или один тест с `subTest`.
5. **6.5)** Практика: табличные тесты валидации/парсинга + условные `skip` по окружению.

### Модуль 7. Test doubles и `unittest.mock`: базовые приёмы мокирования

1. **7.1)** Когда мокать, а когда нет: границы системы (I/O, сеть, время).
2. **7.2)** `Mock` vs `MagicMock`: что даёт «магия» на практике.
3. **7.3)** Настройка поведения: `return_value`, `side_effect` (исключения и последовательности).
4. **7.4)** Проверка взаимодействий: `assert_called*`, `call_args`, `call_count`, `assert_has_calls`.
5. **7.5)** Практика: подмена внешнего клиента/репозитория мок-объектом и изолированное тестирование бизнес-логики.

### Модуль 8. `patch*`: правильная подмена зависимостей

1. **8.1)** `Patch where it is looked up`: патчим место использования, а не определения.
2. **8.2)** `patch()` как декоратор и context manager.
3. **8.3)** `patch.object()` и `patch.multiple()` для атрибутов и нескольких зависимостей.
4. **8.4)** `patch.dict()` для временной правки словарей и `os.environ`.
5. **8.5)** `start()`/`stop()` патчеров в `setUp()` без каскада декораторов.
6. **8.6)** Практика: тест «функция читает ENV -> выбирает поведение» без реальных переменных окружения.

### Модуль 9. Спеки, `autospec` и защита от ложных тестов

1. **9.1)** `spec` / `spec_set`: ограничение мока интерфейсом реального объекта.
2. **9.2)** `autospec=True` и `create_autospec()`: фиксация сигнатур вызова.
3. **9.3)** Динамические объекты и глубокие зависимости: где `autospec` особенно полезен.
4. **9.4)** Баланс: когда спеки мешают и как принять решение.
5. **9.5)** Практика: переход с «голых» моков на `autospec` и анализ вскрывшихся ошибок.

### Модуль 10. Мокирование типовых границ: файлы, классы, сеть, время

1. **10.1)** Мокирование классов: патч конструктора, настройка `return_value`, проверка вызовов.
2. **10.2)** Файлы: `mock_open()` + `patch()` без реальной файловой системы.
3. **10.3)** Сеть/HTTP: моделирование успеха, таймаута, 500 через `side_effect`/`return_value`.
4. **10.4)** Время: патч «текущей даты/времени» для детерминированных тестов.
5. **10.5)** Практика: мини-проект «конфиг -> API-запрос -> обработка ответа» без реального I/O.

### Модуль 11. Продвинутые проверки и диагностика: warnings, logs, вывод, скорость

1. **11.1)** Warnings: `assertWarns` / `assertWarnsRegex`.
2. **11.2)** Логи: `assertLogs` / `assertNoLogs`.
3. **11.3)** Диагностика через CLI: `-b/--buffer`, `--locals`, `--durations`.
4. **11.4)** Полезные сообщения падений: `subTest`, понятные `assert`-сообщения, минимум шума.
5. **11.5)** Практика: «упавший набор -> локализация причины -> исправление -> ускорение медленных тестов».

### Модуль 12. Async в `unittest`: `IsolatedAsyncioTestCase` и `AsyncMock`

1. **12.1)** `IsolatedAsyncioTestCase`: `async def test_*` и управление `event loop`.
2. **12.2)** `asyncSetUp`/`asyncTearDown` и async-cleanup.
3. **12.3)** `AsyncMock`: корректное мокирование async-функций.
4. **12.4)** `patch()` для async-целей: что возвращается и как использовать.
5. **12.5)** Практика: тестирование async-клиента (мок транспортного слоя, `retry/timeout` сценарии).

### Модуль 13. Интеграция в разработку: coverage, tox, CI, поддерживаемость

1. **13.1)** Покрытие кода (`coverage.py`): измеряем, но не подменяем качество метрикой.
2. **13.2)** Запуск в нескольких окружениях (`tox`): версии Python и зависимости.
3. **13.3)** CI-минимум: `python -m unittest discover` + отчёт покрытия на каждый `push/PR`.
4. **13.4)** Анти-паттерны тестов: чрезмерные моки, тесты на реализацию, хрупкие проверки, зависимость от порядка.
5. **13.5)** Рефакторинг под тестируемость: меньше связности, явные зависимости, «тонкие» границы.
