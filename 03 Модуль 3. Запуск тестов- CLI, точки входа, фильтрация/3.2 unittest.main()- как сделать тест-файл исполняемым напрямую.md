# `unittest.main()`: делаем тестовый файл исполняемым и управляем запуском

Быстрый цикл “поправил → проверил” часто упирается не в написание теста, а в запуск: нужно уметь прогонять тестовый файл напрямую, быстро включать подробный вывод, останавливать прогон на первой ошибке, фильтровать набор. В стандартной библиотеке Python это закрывает `unittest.main()` — встроенная точка входа, которая превращает обычный `.py`‑файл с тестами в маленькую CLI‑утилиту.

`unittest.main()` — это **командная программа**, которая загружает тесты из модуля и запускает их; она “в первую очередь предназначена для того, чтобы тестовые модули было удобно исполнять напрямую”. ([Python documentation][1])

## Минимальный шаблон: как сделать файл исполняемым

Идея простая: тесты живут в обычном модуле Python, а запуск добавляется в конце через защитный блок `if __name__ == "__main__": ...`.

```python
# tests/test_calc.py
import unittest

def add(a: int, b: int) -> int:
    return a + b

class TestAdd(unittest.TestCase):
    def test_add_two_numbers(self):
        self.assertEqual(add(2, 3), 5)

    def test_add_negative(self):
        self.assertEqual(add(-2, 3), 1)

if __name__ == "__main__":
    unittest.main()
```

Этот блок делает две вещи:

1. файл можно запускать напрямую: `python tests/test_calc.py`;
2. **ничего не стартует при импорте** (например, когда тесты собираются через discovery). Это критично: discovery загружает тесты *импортом*, а импорт не должен иметь побочных эффектов вроде запуска раннера. ([Python documentation][1])

В документации этот шаблон показан как “самое простое применение” `unittest.main()`. ([Python documentation][1])

## Что именно даёт `unittest.main()`

### 1) Он превращает файл в CLI‑программу

`unittest.main()` “предоставляет интерфейс командной строки для тестового скрипта”. ([Python documentation][1])
То есть, запуская файл напрямую, Вы получаете тот же стиль запуска, что и у `python -m unittest`, только “локально для одного модуля”.

Сразу практический эффект: можно запускать тестовый файл с флагами, например `-v` (подробный вывод). В документации это показано на базовом примере: `-v` включает более высокий verbosity и печатает имена тестов. ([Python documentation][1])

```bash
python tests/test_calc.py -v
```

### 2) Он читает `sys.argv` и умеет принимать аргументы

По умолчанию `unittest.main()` берёт аргументы из `sys.argv`. ([Python documentation][1])
Это означает: всё, что Вы написали после имени файла, попадёт в парсер `unittest`.

Если нужно подменить аргументы программно (например, в ноутбуке или когда тестовый модуль запускается не как отдельный процесс), у `unittest.main()` есть параметр `argv` — список, где первый элемент считается “именем программы”. ([Python documentation][1])

```python
# запуск из интерактивной среды/ноутбука
import unittest

unittest.main(argv=["tests/test_calc.py", "-v"], exit=False)
```

### 3) Он управляет процессом: печатает отчёт и выставляет exit code

По умолчанию `main` вызывает `sys.exit()` с кодом результата: `0` при успехе, `1` при ошибках/падениях. Документация отдельно отмечает код `5`: он означает, что тесты **не были запущены** или **были пропущены**. ([Python documentation][1])

Почему это важно практически: в CI или в проверках качества “успешный” запуск без тестов — это плохой сигнал. Код `5` помогает обнаружить ситуацию, когда набор тестов внезапно стал пустым (например, из‑за проблем с импортом/шаблонами). ([Python documentation][1])

## Как проходит запуск: “что происходит под капотом” в понятной схеме

Ниже логика запуска, если файл выполняется как скрипт и в конце стоит `unittest.main()`.

```mermaid
flowchart TD
  A[Запуск: python tests/test_calc.py] --> B[Модуль выполняется как __main__]
  B --> C[if __name__ == '__main__': unittest.main()]
  C --> D[main читает sys.argv / argv]
  D --> E[main загружает тесты из module='__main__']
  E --> F[Формируется TestSuite]
  F --> G[Запуск через TextTestRunner]
  G --> H[Печать отчёта]
  H --> I[sys.exit(0/1/5) если exit=True]
```

Ключевые точки здесь прямо описаны в документации:
`unittest.main()` загружает тесты из модуля, использует `sys.argv` по умолчанию, и по умолчанию вызывает `sys.exit()` с кодом результата. ([Python documentation][1])

## `unittest.main()` и флаги запуска: что полезно в ежедневной работе

Поскольку `unittest.main()` — CLI для тестового файла, он поддерживает те же опции, что и командная строка `unittest`. В документации `unittest` перечислены ключевые флаги. ([Python documentation][1])

### Подробный вывод: `-v`

Если нужно видеть, какие именно тесты были запущены и в каком порядке, используйте verbosity. В документации показано, что `verbosity=2` даёт подробный вывод. ([Python documentation][1])

```bash
python tests/test_calc.py -v
```

### Остановиться на первой проблеме: `-f/--failfast`

`--failfast` останавливает прогон на первой ошибке или падении. ([Python documentation][1])

```bash
python tests/test_calc.py -f
```

Это полезно, когда Вы чините один дефект и не хотите ждать, пока прогонится весь файл.

### Буферизация вывода: `-b/--buffer`

`--buffer` буферизует `stdout/stderr` во время тестов: вывод “зелёных” тестов выбрасывается, а при падении/ошибке показывается и добавляется в сообщение. ([Python documentation][1])

```bash
python tests/test_calc.py -b
```

Польза: тестовый вывод не “засоряет” лог, но при проблеме остаётся под рукой.

### Удобное прерывание: `-c/--catch`

`--catch` меняет реакцию на Ctrl‑C: текущий тест завершается, затем выводится отчёт по тому, что уже выполнено; второе Ctrl‑C вызывает обычный `KeyboardInterrupt`. ([Python documentation][1])

```bash
python tests/test_calc.py -c
```

### Фильтрация по имени: `-k`

Опция `-k` запускает только тесты/классы, чьё имя совпало с подстрокой или шаблоном (если есть `*`, используется `fnmatch`). Сопоставление идёт по **полностью квалифицированному имени теста**, как его импортировал loader. ([Python documentation][1])

```bash
python tests/test_calc.py -k negative
```

Для отладки это один из самых быстрых фильтров: не нужно переписывать команду на “полное имя теста”, достаточно подстроки.

### Локальные переменные в traceback: `--locals`, и “самые медленные”: `--durations N`

`--locals` добавляет локальные переменные в traceback. ([Python documentation][1])
`--durations N` выводит N самых медленных тест‑кейсов (0 — все). ([Python documentation][1])

Эти флаги особенно полезны, когда тесты начали “тормозить” или когда traceback недостаточно информативен.

## Параметры `unittest.main()`: что и когда настраивать

В документации приведена сигнатура:

`unittest.main(module='__main__', defaultTest=None, argv=None, testRunner=None, testLoader=unittest.defaultTestLoader, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None)` ([Python documentation][1])

Ниже — практический смысл параметров (в компактной таблице).

| Параметр                                        | Когда нужен                                                                          | Что даёт                                                                                                               |
| ----------------------------------------------- | ------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| `module`                                        | Вы запускаете `main()` не из `__main__` или хотите загрузить тесты из другого модуля | Источник тестов для загрузчика (`'__main__'` по умолчанию). ([Python documentation][1])                                |
| `defaultTest`                                   | Нужен “smoke‑набор”, который запускается по умолчанию                                | Имя одного теста или список имён, если через argv не задано, что запускать. ([Python documentation][1])                |
| `argv`                                          | Нужен запуск из IDE/ноутбука/скрипта с контролируемыми аргументами                   | Позволяет задать список CLI‑опций; по умолчанию берётся `sys.argv`. ([Python documentation][1])                        |
| `exit`                                          | Интерактивный запуск (REPL/ноутбук)                                                  | `exit=False` запрещает `sys.exit()`. ([Python documentation][1])                                                       |
| `verbosity`, `failfast`, `catchbreak`, `buffer` | Хотите управлять тем же, чем управляют CLI‑флаги                                     | Имеют тот же эффект, что и одноимённые командные опции. ([Python documentation][1])                                    |
| `testRunner`, `testLoader`                      | Нужна кастомизация раннера/загрузки                                                  | Можно передать класс/экземпляр runner’а и свой loader; по умолчанию — `defaultTestLoader`. ([Python documentation][1]) |

Отдельно полезная деталь: `unittest.main()` возвращает объект, у которого есть `result` (экземпляр `unittest.TestResult`) — это даёт возможность программно анализировать итог прогона. ([Python documentation][1])

## Запуск “внутри” Python и проблема `sys.exit`: `exit=False`

Если Вы вызываете `unittest.main()` внутри интерактивной сессии, `sys.exit()` будет мешать: Python завершит интерпретатор. Поэтому в документации прямо указан режим `exit=False` для интерактивного использования. ([Python documentation][1])

```python
from unittest import main

# Например, в REPL/ноутбуке
program = main(module="tests.test_calc", exit=False, verbosity=2)

# Можно посмотреть сводку программно
print(program.result.testsRun)
print(program.result.wasSuccessful())
```

Здесь важно: `module=...` в интерактивном запуске позволяет загрузить тесты из конкретного импортируемого модуля, а не из `__main__`. Это следует из описания параметра `module` и примера в документации. ([Python documentation][1])

## Чем прямой запуск файла отличается от `python -m unittest` (и почему это иногда ломает импорты)

Оба подхода запускают тесты, но окружение импорта отличается.

### 1) Как выполняется модуль

Когда Python запускается с `-m module-name`, модуль ищется по `sys.path` и выполняется как `__main__`. ([Python documentation][2])
Когда запускается файл как скрипт, он тоже выполняется как `__main__`. ([Python documentation][2])

### 2) Что добавляется в `sys.path`

При `python -m ...` текущая директория добавляется в начало `sys.path`. ([Python documentation][2])
При запуске файла `python path/to/script.py` в начало `sys.path` добавляется директория, где лежит файл. ([Python documentation][2])

Это и есть причина типовых “почему импорт работает в одном режиме и падает в другом”: меняется первый элемент `sys.path`, а значит меняются правила, по которым находятся пакеты проекта.

### 3) Discovery вообще работает через импорт

Discovery (и `python -m unittest discover`) загружает тесты импортом и превращает пути в имена пакетов для импорта. ([Python documentation][1])
Документация также подчёркивает: если тестовый файл не импортируем как модуль, его стоит исполнять напрямую. ([Python documentation][1])

Практический вывод: `unittest.main()` — хороший инструмент “запустить один файл здесь и сейчас”, а `python -m unittest`/`discover` — инструмент “запустить проект как набор импортируемых модулей”.

## Типовые ошибки при использовании `unittest.main()` и как их избегать

### Ошибка 1: запуск тестов при импорте

Если написать `unittest.main()` без `if __name__ == "__main__":`, то при импорте модуля (например, discovery) раннер стартанёт сам. Это конфликтует с тем, что discovery загружает тесты импортом. ([Python documentation][1])

Решение: всегда держать `unittest.main()` под `__name__`‑guard.

### Ошибка 2: “в одном режиме работает, в другом — ImportError”

Это почти всегда следствие разного `sys.path` у `python file.py` и `python -m ...`. Документация описывает, что именно добавляется в `sys.path` в обоих случаях. ([Python documentation][2])

Решение: предпочитайте абсолютные импорты от корня пакета проекта и запускайте тесты из предсказуемого рабочего каталога (обычно из корня репозитория).

### Ошибка 3: “пустой прогон” (код 5) и иллюзия успешности

`unittest.main()` явно сообщает кодом `5`, что тесты не были запущены или были пропущены. ([Python documentation][1])
Решение: в автоматизации сборок трактовать это как проблему конфигурации/структуры тестов, а не как “успех”.

## Заключение

`unittest.main()` — это встроенная точка входа, которая делает тестовый модуль исполняемым напрямую и даёт “мини‑CLI”: чтение `sys.argv`, поддержка ключевых флагов (`-v`, `-f`, `-b`, `-c`, `-k` и др.), печать отчёта и корректные exit codes для автоматизации. ([Python documentation][1])
Для интерактивной работы важны `argv=...` и `exit=False`. ([Python documentation][1])
Для предсказуемости импортов нужно помнить про различия окружения запуска `python file.py` и `python -m module`: они по‑разному модифицируют `sys.path`. ([Python documentation][2])

## Дополнительные материалы

Документация Python `unittest`: базовый пример с `unittest.main()`, сигнатура и поведение `unittest.main()`, CLI‑опции и замечания про discovery. ([Python documentation][1])
Документация Python по запуску через `python -m`: что делает `-m`, почему нельзя `.py`, как меняется `sys.path`, как выполняется `__main__`. ([Python documentation][2])

[1]: https://docs.python.org/3/library/unittest.html "unittest — Unit testing framework — Python 3.14.3 documentation"
[2]: https://docs.python.org/3/using/cmdline.html "1. Command line and environment — Python 3.14.3 documentation"
